---
layout: post
title: Injection de logger avec Spring
author: Alexis Hassler
tags:
- injection
- SLF4J
- logging
- Spring
courses:
- spring
---

Dans mon <a href="http://blog.alexis-hassler.com/2011/06/injection-de-logger-avec-cdi.html">billet précédent</a>, j'ai
mis en place de l'injection contextuelle de logger avec CDI. La solution est particulièrement simple à partir du moment
où on pense à utiliser l'InjectionPoint. Comme sur la plupart de projets actuels, il y a (pour l'instant) beaucoup plus
de <a href="http://www.springsource.org/">Spring Framework</a> que de <a
    href="http://download.oracle.com/javaee/6/tutorial/doc/giwhl.html">CDI</a>, j'ai voulu reproduire l'exemple avec de
l'injection par Spring.<br /><br />Malheureusement, Spring n'a pas d'équivalent à InjectionPoint. Par acquis de
conscience, j'ai posé la question sur le <a
    href="http://www.developpez.net/forums/d1098967/java/general-java/spring/connaitre-point-dinjection/">forum
    developpez.net</a> et sur le <a
    href="http://forum.springsource.org/showthread.php?111071-How-to-get-the-injection-point">forum SpringSource</a>.
C'est sur ce dernier que j'ai eu la piste la plus concrète : créer une annotation spécifique et utiliser un <a
    href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/index.html?org/springframework/beans/factory/config/BeanPostProcessor.html">BeanPostProcessor</a>.
Une chose est sûr, la solution existe probablement, mais de façon moins élégante qu'en CDI.<br /><br />
<!--more-->

Pour choisir le bon PostProcessor, je me suis inspiré des classes de Spring&nbsp;<a
    href="https://fisheye.springsource.org/browse/spring-framework/trunk/org.springframework.beans/src/main/java/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.java?hb=true">RequiredAnnotationBeanPostProcessor</a>&nbsp;et&nbsp;<a
    href="https://fisheye.springsource.org/browse/spring-framework/trunk/org.springframework.beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java?hb=true">AutowiredAnnotationBeanPostProcessor</a>.
A partir de ces exemples, j'ai choisi de créer une classe LoggingAnnotationBeanPostProcessor qui implémente&nbsp;<a
    href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/index.html?org/springframework/beans/factory/support/MergedBeanDefinitionPostProcessor.html">MergedBeanDefinitionPostProcessor</a>.
Cette classe doit être un bean Spring. Dans la méthode&nbsp;postProcessBeforeInitialization, je détecte si le bean qui
s'apprête à être initialisé a un champ avec l'annotation @Logging et je lui injecte un logger
contextuel.<br /><br /><br />
<pre
    class="brush:java">@Component<br />public class LoggingAnnotationBeanPostProcessor<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;implements MergedBeanDefinitionPostProcessor {<br />&nbsp; &nbsp; public void postProcessMergedBeanDefinition(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RootBeanDefinition rootBeanDefinition,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Class beanType,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;String beanName) {<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; public Object postProcessBeforeInitialization(Object bean,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String beanName)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;throws BeansException {<br />&nbsp; &nbsp; &nbsp; &nbsp; Field[] fields = bean.getClass().getDeclaredFields();<br />&nbsp; &nbsp; &nbsp; &nbsp; for (Field field : fields) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (field.getAnnotation(Logging.class) != null) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; injectLogger(bean, field);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return bean;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; private void injectLogger(Object bean, Field field) {<br />&nbsp; &nbsp; &nbsp; &nbsp; ReflectionUtils.makeAccessible(field);<br />&nbsp; &nbsp; &nbsp; &nbsp; ReflectionUtils.setField(field, bean,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LoggerFactory.getLogger(field.getDeclaringClass()));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; public Object postProcessAfterInitialization(Object bean,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;String beanName)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;throws BeansException {<br />&nbsp; &nbsp; &nbsp; &nbsp; return bean;<br />&nbsp; &nbsp; }<br />}</pre>
<br /><br />Ainsi, il me suffit d'annoter mon champ logger avec @Logging pour que l'injection se
fasse.<br /><br /><br />
<pre
    class="brush:java">@Named<br />public class LoggerInjected {<br /><br />&nbsp; &nbsp; @Logging<br />&nbsp; &nbsp; static Logger logger;<br /><br />&nbsp; &nbsp; public void doSomething() {<br />&nbsp; &nbsp; &nbsp; &nbsp; logger.info("I'm doing something");<br />&nbsp; &nbsp; }<br />}</pre>
<br /><br />L'avantage de cette solution sur celle de CDI, c'est qu'elle supporte les champs static. Pour les champs
final, il n'y a aucune amélioration. Le gros inconvénient, c'est que la solution utilise très peu les mécanismes de
Spring. En réalité, elle n'utilise pas l'injection de Spring, tout juste son cycle de vie. De ce fait, le code montré
ici est probablement insuffisant et devra être étoffé pour traiter les cas particulier.<br /><br />Le code source de
l'exemple est publié sur&nbsp;<a href="https://github.com/hasalex/sw-inject/tree/master/spring-logging">GitHub</a>.
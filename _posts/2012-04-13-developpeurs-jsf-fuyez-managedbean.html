---
layout: post
title: Développeurs JSF, fuyez @ManagedBean
date: '2012-04-13T01:17:00.000+02:00'
author: Alexis Hassler
tags:
- JSF
- CDI
modified_time: '2012-09-08T23:40:31.027+02:00'
blogger_id: tag:blogger.com,1999:blog-1829028238633284708.post-5226381369767797650
blogger_orig_url: http://blog.alexis-hassler.com/2012/04/developpeurs-jsf-fuyez-managedbean.html

---

Quand on fait du JSF, on peut déclarer nos beans avec l'annotation JSF @javax.faces.bean.ManagedBean ou avec l'annotation @javax.inject.Named. Dans ce dernier cas, le cycle de vie du bean est géré par CDI qui met les instances à disposition de JSF.<br />On retrouve aussi les deux possibilités avec les annotations liées aux portées, qu'on peut prendre dans le package javax.enterprise.context pour CDI ou dans&nbsp;javax.faces.bean pour JSF.<br /><br />J'ai été confronté récemment à un problème de compatibilité entre CDI et un managed bean JSF. Le bean existait dans une version pure JSF, mais pour faire évoluer l'application, j'ai intégré du CDI. Dans un premier temps, j'ai simplement injecté des dépendances avec l'annotation @Inject.<br /><br /><pre class="brush:java">@ManagedBean<br />@RequestScoped<br />public class FirstBean {<br />    @Inject private Logger logger; &nbsp; <br />    @Inject private SomeEJB someEJB;<br />    ...<br />}</pre><br /><!--more--><br /><br />Dans notre exemple, on injecte un EJB, par la méthode CDI, et un bean CDI produit par ailleurs. Ceci fonctionne sans problème. Pour aller plus loin, j'ai voulu exploiter la technique d'injection contextuelle que j'avais déjà utilisée dans un billet précédent pour <a href="http://blog.alexis-hassler.com/2011/06/injection-de-logger-avec-cdi.html">injecter des loggers</a>. Avec cette technique, le producteur connait l'endroit dans lequel le bean sera injecté grâce à un point d'injection :<br /><br /><pre class="brush:java">@Produces<br />public Logger getLogger(InjectionPoint injectionPoint) {<br />    return Logger.getLogger(<br />               injectionPoint.getBean().getBeanClass().getName());<br />}</pre><br />Et là, patatra, la variable injectionPoint est null, et ce à cause du bean JSF. Pour que ça fonctionne, j'ai dû migrer ce bean en CDI :<br /><br /><pre class="brush:java">@Named("firstBean")<br />@RequestScoped<br />public class FirstBean  {<br />    @Inject private Logger logger; &nbsp; <br />    @Inject private SomeEJB someEJB;<br />    ...<br />}</pre><br />L'injection fonctionne maintenant et le bean peut toujours être utilisé dans JSF. La gestion du bean par CDI procure un fonctionne plus sain.<br /><br />Ce choix entre annotations JSF et CDI est vraiment délicat. @ManagedBean a l'avantage de fonctionner dans des environnements sans CDI, comme Tomcat ou Jetty, mais c'est probablement son seul intérêt. Je pense qu'il faut systématiquement utiliser @Named et oublier les autres possibilités.
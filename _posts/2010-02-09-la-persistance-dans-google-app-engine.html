---
layout: post
title: 'Persistance dans Google App Engine : JDO, JPA ou ... ?'
date: '2010-02-09T22:05:00.008+01:00'
author: Alexis Hassler
tags:
- GoogleAppEngine
modified_time: '2010-03-29T22:05:55.618+02:00'
thumbnail: http://1.bp.blogspot.com/_0XT5UpDEEfE/S3GANe0EjEI/AAAAAAAABaQ/IpSvhd3VrcA/s72-c/gae-localdatastore.png
blogger_id: tag:blogger.com,1999:blog-1829028238633284708.post-2928910136848352794
blogger_orig_url: http://blog.alexis-hassler.com/2010/02/la-persistance-dans-google-app-engine.html

---

Le moteur de persistance de Google App Engine va m'obliger à sortir des sentiers battus. En effet, comme beaucoup de <i>jeunes</i> développeur de ma génération, j'ai toujours stocké mes données dans des bases relationnelles. Or Google nous fournit un stockage de nature NoSQL appelé <a href="http://labs.google.com/papers/bigtable.html">BigTable</a>. Cette technique est propriétaire et a été développée par Google pour le moteur de recherche et Google Earth. Au sein du projet <a href="http://hadoop.apache.org/">Apache Hadoop!</a>, une équipe a repris les spécifications publiées par Google pour créer un moteur similaire appelé <a href="http://hadoop.apache.org/hbase/">Hbase!</a>. Par conséquent, dans mon projet, il n'y aura pas de SQL, pas de JDBC, pas de Foreign Key,...<br />Google nous fournit une API de bas niveau pour accéder à ce stockage, et, pour nous simplifier la tâche, il nous propose aussi les APIs classiques JDO et JPA. Naturellement, je serais tenté d'utiliser JPA car je l'utilise régulièrement pour des projets en architecture plus traditionnelle. Il semble par contre que JDO est mieux supporté. Il apparait clairement que le choix n'est pas évident.<br /><!--more--><h4>JDO ou JPA ?</h4>Quelques explications préliminaires sur le moteur de persistance s'imposent. Les API JDO et JPA sont toutes deux fournies par <a href="http://www.datanucleus.org/">DataNucleus</a>. Ce framework s'appelait, il y quelques mois encore JPOX, et était spécialisé dans le mapping objet / relationnel avec JDO. Progressivement, il est devenu plus polyvalent et est devenu un gestionnaire de persistance multi-environnement : JDO 1, JDO 2 ou JPA 1 (et bientôt JPA 2), bases de données relationnelles, objet (<a href="http://www.db4o.com/">db4o</a>), LDAP, Hbase,... L'historique nous indique pourquoi JDO serait mieux supporté que JPA. Certaines stacktraces nous montrent aussi que le support de JPA est réalisé par une surcouche à JDO : pas très encourageant pour JPA...<br /><br />Par contre, je ne suis vraiment pas motivé pour utiliser JDO. JDO avait tenté de rivaliser avec Hibernate, il y a quelques années puis avait sombré dans l'oubli. Pour tout avouer, je n'étais pas au courant de la sortie de la version 2. Je pensais en toute bonne foi que JDO avais tout simplement été abandonné au profit de JPA. Donc, non, je n'ai vraiment pas envie d'utiliser JDO.<br /><br />JPA est-il aussi mauvais que cela dans App Engine ? En parcourant le Web, on trouve effectivement des <a href="http://www.dotnetguru2.org/bmarchesson/index.php/2009/04/22/google_app_engine_et_jpa_un_support_limi">déçus de JPA</a>, et on comprend rapidement que les contraintes imposées par Google sont fortes, au point d'interdire la conception d'entités utilisables en SGBD/R. Je n'ai pas trouvé d'exemple montrant que JDO fait mieux. Dont acte, je ferai des entités JPA spécialisées pour App Engine. Je les mettrai dans une architecture à base de DAO, ce qui me permettra de basculer vers JDO ou l'API bas niveau si besoin.<br /><h4>JPA dans App Engine</h4>Tout d'abord, on ajoute le fichier de configuration standard <code>src/META-INF/persistence.xml</code>. Je récupère simplement celui proposé dans la documentation de <a href="http://code.google.com/intl/fr/appengine/docs/java/datastore/usingjpa.html">JPA avec App Engine</a>.<br /><pre class="brush: xml">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"&gt;<br />    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence<br />        http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" <br />    version="1.0"&gt;<br />  &lt;persistence-unit name="transactions-optional"&gt;<br />    &lt;provider&gt;<br />      org.datanucleus.store.appengine.jpa.DatastorePersistenceProvider<br />    &lt;provider&gt;<br />    &lt;properties&gt;<br />      &lt;property name="datanucleus.NontransactionalRead" value="true"/&gt;<br />      &lt;property name="datanucleus.NontransactionalWrite" value="true"/&gt;<br />      &lt;property name="datanucleus.ConnectionURL" value="appengine"/&gt;<br />    &lt;/properties&gt; <br />  &lt;/persistence-unit&gt;<br />&lt;/persistence&gt;</pre>On relève quelques options pour les transactions sur lesquelles je devrai revenir plus tard.<br /><h4>Entité simple</h4>Le premier point bloquant pour le développement d'entités portables est la <b>gestion des clés primaires</b>. App Engine propose <a href="http://code.google.com/intl/fr/appengine/docs/java/datastore/creatinggettinganddeletingdata.html#Keys">quatre types de clé</a> :<br /><ul><li><code>java.lang.Long</code> mais uniquement pour les entités qui ne participent à aucune relation ; assez peu utilisable dans la pratique</li><li><code>java.lang.String</code> avec des clés applicatives</li><li><code>com.google.appengine.api.datastore.Key</code> </li><li>Key encodé en String, pour éviter d'utiliser un type propriétaire dans les entités</li></ul>Donc pour faire des entités portables, j'ai le choix entre String applicatif et String encodé. Ayant peu d'affinité avec les String, du moins en tant que clé primaire, je vais faire du spécifique Google avec des Key.<br /><pre class="brush: java">@Entity<br />public final class Person {<br />&nbsp; @Id @GeneratedValue(strategy = GenerationType.IDENTITY)<br />&nbsp; private Key key;<br />&nbsp; private String name;<br />&nbsp; private String forname;<br />&nbsp; // Getters &amp; setters<br />&nbsp; // toString, equals, hashCode<br />}</pre>Je fais ensuite des classes de DAO. Je vous demanderai d'être indulgents sur la qualité du code, ce ne sont que des essais.<br /><pre class="brush: java">public class PersonDAO {<br />&nbsp; private static final EntityManagerFactory FACTORY = Persistence.createEntityManagerFactory("transactions-optional");<br />&nbsp; public Key save(Person person) {<br />&nbsp;&nbsp;&nbsp; EntityManager manager = FACTORY.createEntityManager();<br />&nbsp;&nbsp;&nbsp; EntityTransaction tx = manager.getTransaction();<br />&nbsp;&nbsp;&nbsp; try {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx.begin();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; manager.persist(person);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx.commit();<br />&nbsp;&nbsp;  &nbsp; return person.getKey();<br /> &nbsp;&nbsp; } finally {<br />&nbsp; &nbsp;&nbsp;&nbsp; manager.close();<br />&nbsp;   }<br />&nbsp; }<br /><br />&nbsp; public Person findByKey(Key key) {<br />&nbsp;&nbsp;&nbsp; EntityManager manager = FACTORY.createEntityManager();<br />&nbsp;&nbsp;&nbsp; try {<br />&nbsp; &nbsp;&nbsp;&nbsp; return manager.find(Person.class, key);<br />&nbsp;&nbsp;&nbsp; } finally {<br />&nbsp; &nbsp;&nbsp;&nbsp; manager.close();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />}</pre>Les lecteurs les plus perspicaces auront relevé une ébauche de gestion de transaction dans la méthode <code>save</code>. Si je ne valide pas de transaction, l'entité est tout de même insérée, mais la clé n'est pas renseignée dans l'objet Person.<br />Pour vérifier l'insertion des données en exécution locale, il faut ouvrir l'interface d'administration locale, à l'adresse http://localhost:8888/_ah/admin. On remarquera que les données locales sont stockées dans le fichier <code>war/WEB-INF/appengine-generated/local_db.bin</code>, on peut supprimer le fichier pour vider toutes les données locales, on pourra aussi essayer de se servir de ce fichier pour des donner de tests.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_0XT5UpDEEfE/S3GANe0EjEI/AAAAAAAABaQ/IpSvhd3VrcA/s1600-h/gae-localdatastore.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="228" src="http://1.bp.blogspot.com/_0XT5UpDEEfE/S3GANe0EjEI/AAAAAAAABaQ/IpSvhd3VrcA/s400/gae-localdatastore.png" width="400" /></a></div>Les tests après déploiement fonctionnent parfaitement. L'interface de gestion nous permet de constater que les données sont correctement insérées.<br /><h4>Associations</h4>La plupart des types d'associations sont disponibles et documentées. Je commence par tester les associations one-to-many unidirectionnelles, car on trouve moins de documentation sur le sujet que sur les associations bidirectionnelles. En fait, les seules subtilités concernent les attributs cascade et fetch de l'annotation @OneToMany. Il faut obligatoirement préciser le mode de cascade. Par contre préciser le mode de fetch est inutile car le mode eager est interdit, la notion de jointure n'existant pas.<br /><pre class="brush: java ; highlight: [7, 8];">@Entity<br />public final class Person implements Serializable {<br />&nbsp; @Id @GeneratedValue(strategy = GenerationType.IDENTITY)<br />&nbsp; private Key key;<br />&nbsp; private String name;<br />&nbsp; private String forname;<br />&nbsp; @OneToMany(cascade=CascadeType.ALL)<br />&nbsp; private Set&lt;Link&gt; links;<br />&nbsp; // Getters &amp; setters<br />&nbsp; // toString, equals, hashCode<br />}<br /></pre><br />Les autres types de relations sont aussi gérés, à l'exception des relations many-to-many, pour lesquels, il faut utiliser des Set&lt;Key&gt; et charger les entités associées à la main. Si j'utilise JPA jusqu'au bout, je ferai une page plus détaillée sur les relations JPA dans <a href="http://www.jtips.info/">JTips</a>.<br /><h4>Requêtes JPQL</h4>Puisque tout fonctionne, on peut être un peu plus ambitieux et se lancer dans des requêtes JPQL. Là non plus, il ne faut pas attendre de miracle, seul un support limité est annoncé.<br />Mon premier essai est une recherche avec un critère simple, sur une entité.<br /><pre class="brush: java ;">&nbsp; @SuppressWarnings("unchecked")<br />&nbsp; public List<person> findByName(String name) {<br />&nbsp;&nbsp;&nbsp; EntityManager manager = FACTORY.createEntityManager();<br />&nbsp;&nbsp;&nbsp; try {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Query query = manager.createQuery<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("select p from Person p where p.name like :name");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; query.setParameter("name", name);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List resultList = query.getResultList();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultList.size();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultList;<br />&nbsp;&nbsp;&nbsp; } finally {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; manager.close();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }</person></pre>On remarque le petit <code>resultList.size();</code> qui traine au milieu du code. Il sert juste à gérer un petit problème d'instanciation tardive. Là aussi, il faudrait que je trouve une solution plus élégante.<br /><br />Cela s'est sérieusement gâté lorsque j'ai voulu faire une recherche avec deux critères <i>like</i>. En effet, App Engine ne supporte qu'un seul critère qui ne soit pas une égalité. La requête <code>"select p from Person p where p.name like :name and p.forname like :forname"</code> ne peut pas passer, mais <code>"select p from Person p where p.name = :name and p.forname like :forname"</code> est correcte. Je pense que cette limitation, liée au stockage et non à JPA, constituera une contrainte importante sur l'architecture.<br /><h4>Conclusion</h4>Pour l'instant, je n'ai pas rencontré de limitation bloquante avec JPA, et je n'ai pas vu de décalage important avec ce qui est présenté dans la documentation JDO. Je n'ai donc aucune raison pour privilégier ce dernier. Ce sera donc JPA, avec une petite option sur l'API bas niveau si nécessaire. En tout cas, j'ai abandonné l'idée de faire une application portable sur une base de données relationnelle. Je vais juste essayer d'isoler ce qui est spécifique à App Engine dans les DAO. Et si je n'y arrive pas, les déploiements sur des serveurs autres que ceux de Google devront se faire avec Hbase. Tiens, ce serait intéressant de le tester, quand j'aurai un peu de temps...
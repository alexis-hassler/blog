---
layout: post
title: Devoxx Schedule dans Google Calendar
date: '2010-10-27T11:18:00.009+02:00'
author: Alexis Hassler
tags:
- Rest
- GoogleCalendar
- Devoxx
- Jersey
modified_time: '2010-11-13T23:04:31.521+01:00'
blogger_id: tag:blogger.com,1999:blog-1829028238633284708.post-1907795896555081974
blogger_orig_url: http://blog.alexis-hassler.com/2010/10/devoxx-schedule-dans-google-calendar.html

---

Les organisateurs de la <a href="http://www.devoxx.com/display/Devoxx2K10/Home">conférence Devoxx 2010</a> ont mis à disposition le <a href="http://www.devoxx.com/display/Devoxx2K10/Schedule">planning</a> par une interface REST. Plusieurs <a href="http://www.devoxx.com/display/Devoxx2K10/Schedule+REST+interface">clients</a> ont été développés, en particulier pour des mobiles. A titre personnel, je n'ai ni iPhone ni Android, le plus pratique était donc d'avoir le planning complet dans Google Calendar. J'ai donc décidé de développer un petit programme, en ligne de commande qui lit le planning via l'API REST et qui génère un <a href="https://www.google.com/calendar">agenda Google</a>.<br /><br /><!--more--><br /><h3>Client REST</h3><br />Pour développer le client REST, j'ai choisi d'utiliser Jersey avec Jackson.<br /><pre class="brush:xml"><dependency><br />  <groupid>com.sun.jersey</groupid><br />  <artifactid>jersey-client</artifactid><br />  <version>1.4</version><br /></dependency><br /><dependency><br />  <groupid>org.codehaus.jackson</groupid><br />  <artifactid>jackson-jaxrs</artifactid><br />  <version>1.6.1</version><br /></dependency></pre>La première étape est de développer les classes de données, en s'inspirant du contenu JSON fourni par Devoxx. Par exemple, à partir de la requête "GET http://cfp.devoxx.com/rest/v1/events/1/schedule", j'ai développé une classe ScheduleItem qui ressemble à ça :<br /><pre class="brush:java">@JsonIgnoreProperties(ignoreUnknown = true)<br />public final class ScheduleItem {<br />  public Integer id<br />  public Boolean partnerSlot;<br />  @JsonDeserialize(using = DateAdapter.class)<br />  public Date toTime;<br />  @JsonDeserialize(using = DateAdapter.class)<br />  public Date fromTime;<br />  public String code;<br />  public String type;<br />  public String kind;<br />  public String room;<br />  <br />  public URI presentationUri;<br />  public Presentation presentation;<br />  public Speaker[] speakers;<br />  public String title;<br />}</pre>L'annotation @JsonDeserialize sert à récupérer les dates qui ne sont pas dans un format naturellement compris par Jackson et @JsonIgnoreProperties apporte une souplesse lorsque la réponse JSON ne correspond pas précisément à la structure de la classe.<br /><br />Le deuxième étape est de développer la méthode qui permet d'envoyer les requêtes GET et de récupérer des objets Java :<br /><pre class="brush:java">public <t> T get(String uri, Class<t> clazz) {<br />  ClientConfig cc = new DefaultClientConfig();<br />  cc.getClasses().add(JacksonJsonProvider.class);<br />  Client client = Client.create(cc);<br /><br />  WebResource resource = client.resource(uri);<br />  resource.accept(MediaType.APPLICATION_JSON_TYPE);<br />  return resource.get(clazz);<br />}</pre><br />L'essentiel de la lecture est dans ces quelques lignes de code. Le reste est de l'assemblage : charger les différentes entités, reconstituer les associations, gérer un cache pour améliorer les performances.<br /><br /><h3>Client GCal</h3><br />Les choses se présentent moins simplement du coté des API Google. En gros, j'ai le choix entre la <a href="http://code.google.com/intl/fr/apis/calendar/">Google Calendar API</a> et le <a href="http://code.google.com/p/google-api-java-client/">Google API Client</a>. Les deux librairies utilisent le protocole de communication Atom, la seconde pouvant aussi utiliser REST / JSON. <br /><br />Dans un premier temps, je me suis lancé avec Google API Client qui est disponible dans les repositories publiques de Maven et qui semble plus souple. Après quelques essais, j'ai eu l'impression qu'il me fallait beaucoup de code pour atteindre mon objectif.<br /><br />Je me suis donc rabattu sur Google Calendar API. Pour l'intégration dans mon module Maven, Google n'apporte rien (pour l'instant ?) ; j'ai du fouiller un peu et je suis tombé sur le projet <a href="http://github.com/dcarter/Google-Data-APIs-Mavenized">Google-Data-APIs-Mavenized</a>. J'ai ajouté les dépendances telles qu'indiquées dans le wiki du projet :<br /><pre class="brush:xml"><dependencies><br />  <dependency><br />    <groupid>com.github.dcarter.gdata-java-client</groupid><br />    <artifactid>gdata-calendar-2.0</artifactid><br />    <version>1.41.1-SNAPSHOT</version><br />  </dependency><br />  <dependency><br />    <groupid>com.github.dcarter.gdata-java-client</groupid><br />    <artifactid>gdata-calendar-2.0</artifactid><br />    <version>1.41.1-SNAPSHOT</version><br />  </dependency><br /></dependencies><br /><repositories><br />  <repository><br />    <releases><br />      <enabled>false</enabled><br />      <checksumpolicy>fail</checksumpolicy><br />    </releases><br />    <snapshots><br />      <enabled>true</enabled><br />      <checksumpolicy>fail</checksumpolicy><br />    </snapshots><br />    <id>sonatype-nexus-snapshots</id><br />    <name>Sonatype Nexus Snapshots</name><br />    <url>http://oss.sonatype.org/content/repositories/snapshots</url><br />  </repository><br /></repositories></pre>L'essentiel du travail passe par un objet CalendarService : authentification, création de l'agenda et des événements. Le modèle de données est basé sur des Feed (CalendarFeed, CalendarEntryFeed), qui rassemblent des Entry (CalendarEntry, CalendarEventEntry). La partie la plus périlleuse concerne les URL. Pour chaque calendrier et chaque élément de calendrier, plusieurs URL sont disponibles, en fonction de l'usage ; et ces URL sont très mal documentées.<br /><pre class="brush:java">CalendarEventEntry eventEntry = new CalendarEventEntry(); ...<br />String urlAsText = calendarEntry.getLink(ILink.Rel.ALTERNATE, "application/atom+xml").getHref();<br />CalendarEventEntry insertedEntry = calService.insert(new URL(urlAsText), eventEntry);</pre>Pour l'amélioration des performances, on peut créer les événements en mode batch, avec un URL dédiée !<br /><br /><pre class="brush:java">for (...) {<br />  CalendarEventEntry eventEntry = eventEntry = new CalendarEventEntry();<br />  ...<br />  BatchUtils.setBatchId(eventEntry, batchId);<br />  BatchUtils.setBatchOperationType(eventEntry, BatchOperationType.INSERT);<br />  batchRequest.getEntries().add(eventEntry);<br />}<br />String urlAsText = calendarEntry.getLink(ILink.Rel.ALTERNATE, "application/atom+xml").getHref() + "/batch";<br />CalendarEventFeed batchResponse = calService.batch(new URL(urlAsText), batchRequest);</pre><br />La documentation conseille des lots de 50 à 100 événements. Pour ma part, j'envoie des lots de 175 événements (c'est le programme de Devoxx !), ce qui prend plus d'une minute à traiter.<br /><br /><h3>Conclusion</h3><br />Grâce à ce programme, j'ai créé un agenda public avec le programme de Devoxx 2010. Libre à vous de l'utiliser, ou de recréer votre propre agenda, en adaptant les informations que vous y mettez. Mon code source est disponible sur <a href="http://github.com/hasalex/Devoxx2GCal">GitHub</a>.<br /><br />Il ne me reste plus qu'à préparer mon programme pour les 5 jours de Devoxx. Et rendez-vous là-bas...<br /><br /><iframe src="https://www.google.com/calendar/embed?showTitle=0&amp;showTabs=0&amp;showCalendars=0&amp;showTz=0&amp;mode=DAY&amp;height=600&amp;wkst=2&amp;bgcolor=%23FFFFFF&amp;src=da542njvm5olm12dmhqdqd5v5c%40group.calendar.google.com&amp;color=%231B887A&amp;ctz=Europe%2FBrussels&dates=20101115%2F20101119" style=" border-width:0 " width="600" height="600" frameborder="0" scrolling="no"></iframe>
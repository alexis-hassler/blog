---
layout: post
title: Lecture de fichier : performances [WIP]
author: Alexis Hassler
tags: 
---

Dans le billet précédent, j'ai présenté plusieurs façon de lire des gros fichiers en Java, en me focalisant sur la consommation de mémoire pour _buffers_ directs.
J'y ai ajouté quelques vagues considérations de performances.

Je présente ici quelques données chiffrées sur ces comparaisons de performances.

//<!--more-->

== Tests

Je compare 4 façons de lire des gros fichiers:

* Files.readAllBytes(path)
* InputStream
* FileChannel avec un petit buffer
* AsyncFileChannel avec un petit buffer

Avant de commencer les tests, j'ai créé 10 fichiers dont la taille est comprise entre 250 et 500 Mo.

Pour chaque test, je lis les 10 fichiers de façon séquentielle et je boucle plusieurs fois sur cette séquence.
Le nombre de boucles est paramétrable ; je le fais varier en 5 et 50.

La mémoire allouée est suffisante pour tous les tests.

J'ai réalisés ces tests sur 2 machines différentes:

* Intel® Core™ i7-6820HQ CPU @ 2.70GHz × 8, SSD, 32 GB
* Intel® Core™ i7-..., SSD, 16 GB

Toutes deux tournent sur Ubuntu 18.04.

Pour chaque machine, j'ai fait des tests en Java 11, 14 et 8 (?)

Tests Windows ?

== Résultats

*Linux n°1 - Java 11* (référence)

Temps moyen de lecture d'un fichier: 

* async_file_channel: 86 ms
* file_channel: 107 ms
* input_stream: 230 ms
* read_all_bytes: 138 ms

*Linux n°1 - Java 14*

Temps moyen de lecture d'un fichier: 

* async_file_channel: 103 ms (+20%)
* file_channel: 120 ms (+12%)
* input_stream: 261 ms (+13%)
* read_all_bytes: 157 ms (+14%)

*Linux n°1 - Java 8*

Temps moyen de lecture d'un fichier: 

* async_file_channel:  ms (+%)
* file_channel:  ms (+%)
* input_stream:  ms (+%)
* read_all_bytes:  ms (+%)

*Linux n°2 - Java 11*

Temps moyen de lecture d'un fichier: 

* async_file_channel:  ms (+%)
* file_channel:  ms (+%)
* input_stream:  ms (+%)
* read_all_bytes:  ms (+%)


*Windows - Java 11*

Temps moyen de lecture d'un fichier: 

* async_file_channel:  ms (+%)
* file_channel:  ms (+%)
* input_stream:  ms (+%)
* read_all_bytes:  ms (+%)

== Analyse

Ma démarche n'a peut-être pas la même rigueur qu'une étude clinique menée par un professeur marseillais, 
mais les résultats sont suffisamment homogènes pour tirer des conclusions.

La variante la plus lente est systématiquement et assez nettement `InputStream`.
C'est bien la preuve que NIO a bien apporté des améliorations avec l'usage des _direct byte buffers_.

Il est suivi de Files.readAllBytes(path), qui est relativement lent malgré la quantité de mémoire allouée.

Les variantes les plus efficaces sont FileChannel et AsyncFileChannel. 
L'écart entre les deux est assez faible (10%) et l'ordre dépend de la machine de test.
L'excès de complexité amené par AsyncFileChannel n'est donc pas rentable dans mon exemple.

Le vainqueur est donc FileChannel, avec un buffer de 64 ko.
